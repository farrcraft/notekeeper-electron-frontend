import {
  app,
  session,
  shell,
  ipcMain,
  WebContents
} from 'electron';
import installExtension, { REACT_DEVELOPER_TOOLS, MOBX_DEVTOOLS } from 'electron-devtools-installer';
import path from 'path';
import { URL } from 'url';

import AppUpdater from '../AppUpdater';
import Backend from '../Backend';
import {
  Certificate,
  Logger
} from '../../core';
import Window from '../Window';
import { Rpc } from '../../rpc';
import {
  Api,
  Registrar
} from '../../api';
import { Kex } from '../../api/endpoints';


/**
 * The Application that runs in the main process
 */
class App {
  /**
   *
   */
  logger: Logger;

  /**
   * The window where the renderer process lives
   */
  window: Window;

  /**
   * The backend server process
   */
  backend: Backend;

  /**
   * The API used for communicating with the backend server process
   */
  api: Api;

  /**
   * The underlying RPC mechanism through which the API communicates with the backend server process
   */
  rpc: Rpc;

  /**
   * The SSL certificate generated by the backend server process
   */
  certificate: Certificate;

  /**
   *
   */
  constructor() {
    const userDataPath: string = app.getPath('userData');
    this.logger = new Logger(userDataPath);

    // The RPC module talks to the backend
    this.rpc = new Rpc();
    // The API layer uses the RPC as its transport layer
    this.api = new Api(this.rpc);

    const registrar = new Registrar();
    registrar.register(this.api);

    const certPath = path.join(userDataPath, 'certificate');
    this.certificate = new Certificate(certPath);

    this.backend = new Backend(this.logger, () => this.onBackendReady());
    this.window = new Window(this.api);
  }

  /**
   *
   */
  onSecondInstance(): void {
    if (!this.window || !this.window.window) {
      return;
    }
    if (this.window.window.isMinimized()) {
      this.window.window.restore();
    }
    this.window.window.focus();
  }

  /**
   *
   */
  onWillQuit(): void {
    this.backend.terminate();
  }

  /**
   *
   * @param event
   * @param contents
   */
  onWebContentsCreated(_event: Event, contents: WebContents): void {
    // Security - Disable navigation
    contents.on('will-navigate', (navEvent, navigationUrl) => {
      const parsedUrl = new URL(navigationUrl);
      if (parsedUrl.origin !== 'https://notekeeper.io') {
        navEvent.preventDefault();
      }
    });

    // Security - Prevent opening new windows
    contents.on('new-window', (windowEvent, navigationUrl) => {
      // Allow new devtools to be updated when in dev
      if (
        process.env.NODE_ENV === 'development'
        && navigationUrl.startsWith('chrome-devtools://')
      ) {
        return;
      }

      windowEvent.preventDefault();
      // Open event's url in the default browser
      shell.openExternal(navigationUrl);
    });

    // Security - Verify webview options
    contents.on('will-attach-webview', (viewEvent, webPreferences, params) => {
      // Strip away preload scripts if unused or verify their location is legitimate
      const webPrefs = webPreferences;
      delete webPrefs.preload;
      delete webPrefs.preloadURL;

      // Disable Node.js integration
      webPrefs.nodeIntegration = false;

      // Verify URL being loaded
      if (!params.src.startsWith('https://notekeeper.io/')) {
        viewEvent.preventDefault();
      }
    });
  }

  /**
   * Setup all of the event handlers for the electron app
   */
  registerHandlers(): void {
    app.on('second-instance', (/* event, commandLine, workingDirectory */) => this.onSecondInstance());

    /*
    app.on('activate', (): void => {
      if (mainWindow === null) {
        // [FIXME] - expects some parameters here
        mainWindow.create();
      }
    });
    */

    // all windows have been closed & app is about to quit
    app.on('will-quit', () => this.onWillQuit());

    // Security-related configuration
    // See: https://electronjs.org/docs/tutorial/security
    app.on('web-contents-created', (event, contents) => this.onWebContentsCreated(event, contents));

    app.on('window-all-closed', () => this.onWindowAllClosed());

    app.on('ready', () => this.onReady());
  }

  onBackendStarted() {
    // The backend is only guaranteed to be in its initial service ready state
    // where its at least created the SSL certificate, but might not yet be
    // ready to service RPC requests.
    let ok = this.rpc.waitForReady(this.onBackendReady);
  }

  /**
   * Once the backend is ready, we create the main browser window
   */
  async onBackendReady(): Promise<void> {
    const installExtensions = async (): Promise<void> => {
      if (process.env.NODE_ENV === 'development') {
        return installExtension([REACT_DEVELOPER_TOOLS.id, MOBX_DEVTOOLS.id])
          .then(name => console.log(`Added Extension:  ${name}`))
          .catch(err => console.log('An error occurred: ', err));
      }
    };

    await installExtensions();

    this.setContentSecurityPolicy();

    try {
      this.certificate.load();
    } catch (err) {
      // [FIXME] - need to shutdown from here
      app.quit();
    }
    this.rpc.certificate = this.certificate.certificate;

    // The backend is only guaranteed to be in its initial service ready state
    // where its at least created the SSL certificate, but might not yet be
    // ready to service RPC requests.
    let ok = await this.rpc.waitForReady();
    if (!ok) {
      // [FIXME] - shutdown
      console.log('gave up waiting for rpc.');
      app.quit();
    }

    // [FIXME] - should use constant of some kind of endpoint name here?
    const kex = <Kex>this.api.getEndpoint('kex');
    try {
      kex.keyExchange();
    } catch (err) {
      console.log('key exchange failed ' + err);
      // [FIXME] - shutdown
      app.quit();
    }

    // The bridge will make an IPC request for the backend's public key.
    // Without it, the renderer process won't be able to make backend RPC calls.
    ipcMain.on('verify-public-key', (event): void => {
      event.returnValue = this.rpc.client.verifyPublicKey;
    });

    // next we need to:
    // make an api call to open the master db
    // make an api call to load the window state
    // create the window

    /*
    await dbMain.openMasterDb();

    await uiStateStore.load();
    let width: number = uiStateStore.windowWidth;
    let height: number = uiStateStore.windowHeight;
    if (width <= 0) {
      width = 800;
    }
    if (height <= 0) {
      height = 600;
    }

    this.window.create(
      width,
      height,
      uiStateStore.windowXPosition,
      uiStateStore.windowYPosition
    );
    */

    // Remove this if your app does not use auto updates
    // eslint-disable-next-line
    new AppUpdater();
  }

  /**
   * Once the Electron app is in a ready state, we are ready to start the backend
   * process and open the main browser window.
   */
  onReady(): void {
    // Start the backend process - it will call the ready listener when it is ready
    // We will pick back up again in onBackendReady().
    this.backend.start();
  }

  /**
   *
   */
  async onWindowAllClosed(): Promise<void> {
    try {
      /*
      await uiStateStore.save();

      // The most secure option is to completely sign out the user when they close the main window
      // The user will need to do a full signin the next time they open the app
      if (accountStore.signedIn === true) {
        await accountTransport.signout();
      }
      */
      // If the user has opted into the less secure "remember me" option
      // then we can just lock instead:
      /*
      if (accountTransport.store.locked === false) {
        await accountTransport.lock();
      }
      */
    } catch (e) {
      this.logger.debug(e);
    }
    // Used to be in shared/Core.js - there is currently not RPC shutdown logic
    // Core.shutdown();

    // Respect the OSX convention of having the application in memory even
    // after all windows have been closed
    if (process.platform !== 'darwin') {
      app.quit();
    }
  }

  /**
   * Security - Set CSP HTTP Header
   */
  setContentSecurityPolicy(): void {
    if (session.defaultSession === undefined) {
      return;
    }
    session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          'Content-Security-Policy': ["default-src 'self'"]
        }
      });
    });
  }
}

export default App;
